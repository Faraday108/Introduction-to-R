---
title: "R Syntax Examples"
author: "Nathan Young"
output: pdf_document
---

# R Nuts and Bolts
## Entering Input
We type expressions into the R prompt. 
The <- symbol is the assignment operator
```{r}
x <- 5 # Assignment of value to variable
print(x) # Explicit printing
x # auto-printing
y <- 10:20
```
When [1] is printed it indicates that x is a vector and that 5 is the first element
The : operator is used to create integer sequences

## R Objects
R has five basic classes of objects
- Character
- Numeric (real numbers)
- Integer
- Complex
- Logical (True/False)

The vector is the most basic object type, initialized with vector() function.  
A vector can only contain objects of the same class
A *list* is represented as a vector but can contain objects of different classes. 

## Numbers
Numbers are generally treated as numeric objects (such as double precision real numbers). Meaning, even if you see a '1' it is represented behind the scene as a numeric object like '1.00'. 
If you explicitly want an integer, use the L suffix. Entering '1' gives you a numeric object, while entering '1L' gives an integer object.   
Inf represents infinity. 
NaN represents an undefined value such as 0/0

## Attributes
R Objects can have many attributes (like metadata) to help describe the object. 
* Names, dimnames
* dimensions (matrices, arrays)
* class (integer, numeric)
* length
* other user-defined attributes/metadata

Attributes can be accessed using attributes() function. 

## Creating Vectors
The c() function can be used to create vectors of objects by concatenating things together. 
```{r}
x <- c(0.5, 0.6)       # numeric
x <- c(TRUE, FALSE)    # logical
x <- c(T, F)           # logical
x <- c("a", "b", "c")  # character
x <- 9:29              # integer
x <- c(1+0i, 2+4i)     # complex
x <- vector("numeric", length = 10) # initialize vector
```

## Mixing Objects
Sometimes we mix objects (on accident or on purpose).  
When different objects are mixed in a vector, they are *coerced* to be the same class. Sometimes this works the way you expect others, not. 

## Explicit Coercion
You can explicitly coerce between classes using the as.* function
```{r}
x <- 0:6
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
```
Sometimes, R doesn't know what to do and will return NA. 

## Matrices 
Vectors with a *dimension* attribute. The dimension attribute is an integer vector of length 2
```{r}
m <- matrix (nrow = 2, ncol = 3)
dim(m)
attributes(m)
```
Matrics are constructed *column-wise*, so entries can be thought of starting in the "upper left" corner and running down the columns. 
```{r}
m <- matrix(1:6,nrow = 2, ncol = 3)
m
```
Can also be created directly from vectors by adding a dimension attribute. 
```{r}
m <- 1:10
m
dim(m) <- c(2,5)
m
```
Can be created with *column-binding* or *row-binding*
```{r}
x <- 1:3
y <- 10:13
cbind(x,y)
rbind(x,y)
```

## Lists
Special vectors that contain different elements of different classes.  
Can be explicitly created with the list() function. 
```{r}
x <- list(1, "a", TRUE, 1+4i)
x
```
Can also create an empty list of length with the vector() function.  
```{r}
x <- vector("list", length = 5)
```

## Factors
Used to represent categorical data that is unordered or ordered. Akin to integer vector where each integer has a label. Important for statical modeling and treated special in functions like lm() and glm().  
Using factors with labels is better than using integers because factors are self-describing. 
Factor with values "Male" and "Female" is better than variable with values 1 and 2. 
Create with factor() function
```{r}
x <- factor(c("yes", "yes", "no", "yes", "yes"))
x
table(x)
unclass(x)
```
Often, factors are automatically created when reading data with function like data.table().  
Order of levels can be set using levels argument to factor(). Often important in linear modeling with first level as baseline. 

## Missing Values
Denoted by NA or NaN for undefined mathematical operations
- is.na() is used to test for NA
- is.nan() is used to test for NaN
- NA values have a class also (integer NA, character NA, etc)
- A NaN value is also NA

```{r}
# create a vector with NAs in it
x <- c(1,2,NA,10,NaN,3)
# Return logical vector indicating which elements are NA
is.na(x)
# Return logical vector indicating which elements are NaN
is.nan(x)
```

## Data Frames
Used to store tabular data in R. Important in many statistical modeling. dplyr has optimized set of functions to work with data frames.  
Represented as special type of list where everyelement of the list has to have the same length. Each element can be thought of as a column and the length of each element of the list is the number of rows.  
Unlike matrices, can store different classes of objects in ach column.  
In addition to column names, DF have attribute called row.names to indicate informration about each row.  
Usually created by reading a dataset using read.table() or read.csv(). Can be created with data.frame() or converted from other objects.  
Can be converted to matrix with data.matrix(). 
```{r}
x <- data.frame(foo = 1:4, bar = c(TRUE, TRUE, FALSE, FALSE))
x
nrow(x)
ncol(x)
```

## Names
R objects can have names, helpful for readable code. 
```{r}
x <- 1:3
names(x)
names(x) <- c("New York", "Seattle", "Los Angeles")
x
names(x)

# Lists can also have names
x <- list("Los Angeles" = 1, Boston = 2, London = 3)
x
names(x)

# Matrices can have both row and column names
m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a","b"),c("c","d"))
m
# Column names and row names can be specified separately
colnames(m) <- c("h","f")
rownames(m) <- c("x","z")
m
```
Note that for dataframes, there is a separate function for setting row names, the row.names(). DF do not have column names, just names. So you use the names() function. 

# Getting Data In and Out of R
## Reading and Writing Data
There are a few principal functions
- read.table, read.csv for reading tabluar data
- readLines for reading lines of a text file
- source, for reading in R code files (inverse of dump)
- dget, for reading in R code files (inverse of dput)
- load, for reading in saved workspaces
- unserialize, for reading simple R objects in binary form. 

Many packages exist for other datasets

Analogous functions for writing to files
- write.table for writing tabular to text files or connections
- writeLines, for writing character data line-by-line to file or conn
- dump, for dumping a textual representation of multiple R objects
- dput, for outputting a textual representation of an R object
- save, for saving an arbitrary number of R objects in binary format to a file
- serialize, for converting an R object into a binary format for outputting to a connection. 

## Reading Data Files with read.table()
Commonly used. Help file is worth reading. 
Arguments: 
- file, name of file, or connection
- header, logical indicating if file has a header
- sep, a string indicating how columns are separated
- colClasses, character vector indicating the class of each column
- nrows, number of rows. Default reads whole file
- comment.char, chacter string indicating comment character. 
- skip, number of lines to skip from beginning
- stringsAsFactors, should character variables be coded as factors? defaults to True. 

For small to moderate size, you can usually call read.table
```{r}
#data <- read.table("foo.txt")
```
- In this case, R will automatically skip lines that begin with #
- figure out how many rows there are and how much mem is needed. 
- figure out type of variable in each column. 

Telling R these things directly makes R faster and more efficient. 

## Reading in larger data sets with read.table
With larger data sets, make life easier and prevent R from choking by: 
- Read the help page for read.table
- Make a rough calculation of the memory required to store your dataset. If dataset is larger than RAM, stop. 
- set comment.char = "" if no commented lines in file
- Use colClasses argument. Specifing this can make it run **much** faster, often twice as fast. 

```{r}
#initial <- read.table("datatable.txt",nrows=100)
#classes <- sapply(initial,class)
#tabAll <- read.table("datatable.txt",colClasses=classes)
```
- set nrows. Doesn't make faster but helps with memory. 

Also useful to know about your system. 
- How much mem is available? 
- Can you close other applications? 
- Are there other users logged in? 
- What OS are you using? Some limit amount of memory. 

## Calculating Memory Requirements for R Objects
Because R stores all objects in physical memory, important to keep limits in mind. Especially when reading in a new dataset to R. BOTE are easy for it.  
Suppose data frame with 1,500,000 rows and 120 columns all of which are numeric. How much memory to store numeric data? 
1,500,000 x 120 x 8 bytes/numeric
= 1,440,000,000 bytes 
= 1,400,000,000 / 2^20 bytes/MB
= 1,373.29 MB
= 1.34 GB.

# Using the readr Package
Recently developed to deal with reading large flat files quickly, replacement for read.table() and read.csv(). Ananogous in readr are read_table() and read_csv().  
For the most part, can use these instead. 
```{r}
library(readr)
#teams <- read_csv("data/team_standings.csv")
#teams
```
By default, will open and read lint-by-line. Will also, read first few rows of table to figure out type of column. Can instead specify type of each column with col_types argument. Good idea in general.  
col_types accepts a compact representation. "cc" says first and second columns are characters.  
read_csv also reads compressed files automatically, no need to decompress.  
Can specify column type in detailed fashion using various col_* functions. 

